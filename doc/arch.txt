
getCanvas() - возвращает не указатель, а экземпляр Canvas для рисования не в OnPaint. Это не в базе, 
  а в реализации. Или не? На самом деле, пусть возвращает shared_ptr<ICanvas> - по факту нам канвас не нужен 
  на каждый чих, и ремап мышкиного положения в позицию на канвасе нужен в мышиных событиях, и всё. 
  А там и так нужен канвас.

getCanvasForPaintEvent() - возвращает shared_ptr<ICanvas> для события OnPaint. В винде есть разделение 
  по способу получения HDC в зависимости от типа события. В других системах методов может быть больше
  - будем добавлять вирт методы по нужде, или меньше - тогда везде реализация будет одинаковая.

void prepareCanvasScaleOffset(shared_ptr<ICanvas>) - туда передаётся указатель, там Canvas настраивается. 
  Метод нужен в тч, чтобы прокинуть его в белку, и знать, как белка его настроила. Это вирт метод в базе.
  Отдельный хендлер в белке!!!

При этом в канвасе уже должен быть выбран кешированный бекграунд.
Или не?
bool selectCachedBackground(shared_ptr<ICanvas>) - метод для загрузки кешированного фонового изображения в канвас.
  Возвращает true, если в canvas было загружено кешированное фоновое изображение
  Пользователь тут может выбрать в канвас кешированное изображение бекграунда и вернуть true, или вернуть false 
  для отрисовки бекграунда, или выбрать вообще самое фоновое-фоновое изображение и вернуть false, чтобы поверх
  самого-самого фонового изображения пользователь отрисовал свой буль-менее статичный бекграунд, который
  будет кеширован.

Примерные сценарии при условии использования библиотеки виджетов совместно с игровым движком:

Последовательность событий рисования для отрисовки сцены с нуля (например, в onPaint):
  0) Создаём Canvas - getCanvasForPaintEvent
     Настраиваем - prepareCanvas
  1) drawSceneBackground        - отрисовка фона сцены. Тут после отрисовки производим кеширование бекграунда.
     Отдельный хендлер в белке!!!
  2) drawSceneAnimation         - отрисовка текущих фаз анимации спрайтов и тп.
     Отдельный хендлер в белке!!!
  3) drawSceneControls          - отрисовка статичных контролов.
     Отдельный хендлер в белке!!!
  4) drawSceneControlsAnimation - отрисовка текущих фаз анимации контролов, которые меняют своё состояние.
     Отдельный хендлер в белке!!!
  5) drawDragItems              - отрисовка динамической фигни по перетаскиванию контрола и/или спрайта
     Отдельный хендлер в белке!!!
  6) drawMouseState             - отрисовка всякой динамической фигни, которая меняется в мышиных событиях,
     Отдельный хендлер в белке!!!
     например, при нажатии кнопки мыши, для выделения какого-то региона - отрисовываем рамку выделения, 
     например, в данном случае - это событие дёргается, когда мы перерисовываем сцену, но не в обработчике мыши;
     или какой-то текущий хот-трекинг, но опять же не в машкином событии.
     Раньше для подобного делали просто XOR-рисвоание, но это убого выглядит на текущий момент.

У нас есть таймерное событие, которое вызывает пересчет положений элементов сцены.
По результатам этого пересчета сцена может измениться, но может и остаться неизменной (подразумевается основной бекграунд сцены).

Если сцена требует обновления основного бекграунда сцены, то invalidateAll и идём по предыдущему сценарию. Иначе алгоритм такой:
  0) Создаём Canvas - getCanvas
     Настраиваем - prepareCanvas
  1) if (!selectCachedBackground(pCanvas)
        {
            // Отдельный хендлер в белке!!!
            drawSceneBackground(pCanvas); // Тут после отрисовки производим кеширование бекграунда.
        }
  2-6) Как в предыдущем сценарии


По событиям мыши отрисовка работает по предыдущему сценарию, кроме пункта 6 - вместо этого в мышиное событие
передаётся канвас, и юзер там резвится, как хочет, но запоминая свои приколюхи для того, чтобы по требованию
они были перерисованы в drawMouseState.

Основная цель такого дробления отрисовки на фазы в том, чтобы пользователь мог поверх игрового поля c 
анимациями и прочим пользоваться стандартными контролами, при этом он может заменить отрисовочный хендлер 
контролов на свой, и рисовать контролы в своём оригинальном стиле - поддержка "тем".

У нас сейчас есть GDI и GDI+ бекэнды. GDI шустр, GDI+ - красив при рисовании линий и тп, делает размытие,
но тормоз. Тем не менее, BitBlt, StrechBlt, да и AlphaBlend - довольно шустры даже на довольно старых 
процессорах. Торомза возникают при большом количестве примитивов типа линий, прямоугольников, окружностей/
эллипсов и тд и тп, особенно с GDI+. А контролы - это как раз в основном такие примитивы.

Другие бекэнды, ориентированные на работу с графическим процессором веротяно работают быстрее, но не факт,
что там можно что-то закешировать. В этом случае selectCachedBackground всегда будет возвращать false.

Если у нас игра, то экран занят скорее всего игровым полем, и контролов на нём минимальное количество. 
Тут нет особых проблем в быстродействием.

Если у нас игра, и мы нажали, например, Escape - у нас появилось меню, обычно из кнопок - и в фоне либо
всё замирает, либо основной бекграунд остаётся неизменным, но анимации подёргиваются/анимируются, чтобы
пользователю было не скучно. Поверх этого обычно рисуется меню из кнопок и работает подсистема контролов.
sceneUpdate при этом по таймеру не вызывается, перерисовка базы сцены не нужна, и всё работает приемлемо
по скорости. 

А что, если у нас не игровое приложение? Тут, наверное, надо либо запретить UpdateScene таймер, либо не
иметь его вообще. А если у нас приложение-мутант - в какие-то моменты - офисное, в какие-то моменты -
игровое - наверное надо дать пользователю (конечному программисту) возможность управлять данным аспектом.

Надо ли нам вводить концепцию clipping regions? Для GDI/GDI+ наверное это могло бы что-то ускорить.
В других бекэндах не факт, что это вообще существует, и, весьма вероятно, что они настолько быстры в 
отрисовке, что там насрать на эти clipping regions и они, если и есть, то только будут тормозить. 
Возвожно, что перерисовать сцену целиком будет быстрее, чем мудохаться с обновлением сцены с учетом 
clipping regions.

Тем не менее, вопрос производительности надо держать в уме. Если мы перерисовываем
отдельный контрол, то в некоторых случаях нам может быть дешевле заново восстановить фон под ним,
и отрисовать текущее состояние контрола на восстановленом фоне, чем перерисовывать все контролы.
В других случаях дешевле будет рисовать всё с нуля.

!!! Тут пока нет однозначного решения, которое можно было бы сделать универсальным, и тюнить
его через настройки конкретной рализации. Надо думать !!!


Контролы

Размеры и положение

Размеры и положение контролов задаются в координатах канваса относительно родительского контрола
и не учитывают scale и offset canvas'а - он сам их аплаит при всех отрисовках. 


Контролы могут быть объединены в группы контролов. Им нужен для этого какой-то контейнер.
Наверное, это будет тоже Control, какой-то базовый контрол, типа Panel, наверное, практически прямой 
наследник ControlBase.

Вопрос - а нафига иметь Panel, который закрашивает фон каким-то цветом? Если у нас форма, то заливкой
фона занимается она, если у нас игра, то нам никакая заливка не нужна, мы рисуем поверх игры.
Окей - Panel не занимается закраской фона, Panel - прозрачный.
Если нам нужен непразрачный Panel - тут либо отдельный класс OpaquePanel, либо свойство transparency,
со значением по умлчанию - transparent. Лучше флаг.


Идентификаторы для библиотечных контролов

Нужны целочисленные идентификаторы для всех библиотечных контролов, для идентификации их типов в различных
фабриках. Пользователи могут создавать свои типы контролов. Все касты остаются на совести пользователей.

Или не целочисленные, а строковые? Это более гибко и перспективно в плане расширения.


Controls HitTest.

По дефолту у нас все контролы - прямоугольники. Но это не факт. Контролы могут быть фигурными донельзя,
особенно в игре.
Нам нужен HitTestHandler - если не задан, вызывается по умолчанию rectHitTestHandler.
У каждого контрола должна быть возможность иметь свой HitTestHandler.
Контейнеры игнорируют это поле.
По умолчанию контролу присваивается дефолтный HitTestHandler, если фабрике контролов не задана фабрика
HitTestHandler'ов.

Если HitTestHandler не знает, для какого типа контрола он вызывается, работает стандартный rectHitTestHandler.


Панели и подобные контейнеры контролов.
Панели и контейнеры не должны по идее получать сообщения мышки и клавиатуры, им самим это особо не зачем.
Но они должны уметь находить контрол в своём содержимом, на котором произошел клик.
Наверное это поведение не стоит зашивать, а оно будет управляться флагом - alowSelfHitTest или disableSelfHitTest.
Ну или что-то подобное (см. далее, там есть).


Z-order. Для простоты Z-order будет определяться порядком контрола в векторе контейнера.
В начале - меньший z-order, в конце - больший. HitTest производится от начала к концу, 
отрисовка - от конца к началу.

Какой контейнер использовать для дочерних контролов? vector? list? deque? Или самому список запилить, указатели 
prev/next прямо в контроле?


TabOrder - хм, надо подумать, как это сделать. Целочисленное поле? При добавлении контрола оно автоматом 
увеличивается относительно предыдущего, или можно установить явно (и при этом переустановить счетчик 
автоматического TabOrder'а?)

Группы контролов, по которым можно перемещаться курсорными клавишами. Обдумать???

ctrls_groupping.txt - там описание и ссылки на инет с этим описанием, как в винде работает
WS_GROUP/WS_TABSTOP/WS_EX_CONTROLPARENT
В крации - WS_GROUP/GroupStart задаёт первый элемент группы, остальные элементы группы попадают в группу в 
порядке добавления в окно. Элементы группы могут иметь стиль TabStop, но могут и не иметь его.
Но обычно GroupStart нужен как раз для групп элементов, которые не имеют стиля TabStop - для перемещения
между элементами курсорными клавишами. Клавиша Tab/Shift+Tab (или другая аналогичная в других системах) - 
перемещает фокус ввода на элемент либо со стилем GroupStart, либо со стилем TabStop. При перемещении
фокуса по табу на группу элементов без стиля TabStop фокус устанавливается на элемент группы, который был в 
фокусе последним до смены фокуса с данной группы.

Нужно завести State-флаги:
hasFocus/inFocus - контрол, обладающий фокусом ввода в текущий момент. Только один контрол на форме/в окне 
  может иметь этот флаг установленным.
groupFocus - элемент, который обладает фокусом в группе. Если группа не имеет фокуса, то такой контрол ничем 
  не отличается от остальных. При получении группой фокуса ввода фокус ввода устанавливается на данный контрол.
  Такой State-флаг может быть установлен только у одного контрола в группе. Если в группе нет контрола
  с установленным данным флагом, то фокус устанавливается на первый контрол группы.


WS_EX_CONTROLPARENT - составной контрол, сам в навигации не участвует, участвуют его дочерние элементы.
  Сделаем style-флаг ControlParent/ControlContainer/Container.
  Составные контролы могут быть разными - тот же комбобокс с дропдаун листом - это комбинация edit+button+list,
  но они работают как единое целое.
  Или панель/лейаут - он прозрачен для всего, его как будто не существует вообще, только его контролы.
  Всё хранится в одном списке, но поведение разное.


Ещё раз про TabOrder. А насколько он нам вообще нужен? Обдумать!!!
  TabOrder список обновляем в форме при добавлении контролов в любой под-контрол.
  А при изменении стилей контрола? А стили контрола не изменяются никогда, они фиксируются при создании.
  Для изменяемых "стилей" у нас есть отдельно ControlStateFlags, но там только Disabled и подобное,
  это влияет на обработку табов и мыши, но это не критично.

TabOrder, как и Z-order, определяется порядком добавления в родительский контрол, только Z-order - он работает
внутри контролов родительского контрола, а TabOrder - в рамках окна.
Если нам надо изменить Z-order, то сделаем методы:
  zOrderMoveBefore(pControlBefore, pControl)
  zOrderMovetAfter(pControlAfter, pControl)
Контрол должен быть уже добавлен, и это работает только в пределах родительского контрола.
Для TabOrder ситуация аналогичная, только это работает уже в рамках хост-окна, хотя, доступ можно дать и через
отдельный контрол. И, в отличие от Z-order, TabOrder-функции работают с группами. Если контролы
pControlBefore/pControlAfter/pControl - являются членами групп, то перемещение будет произведено для всей группы,
и новая вставка будет сделана до/после целевой группы.


Флаги контрола (см также https://learn.microsoft.com/en-us/windows/win32/winmsg/window-styles)

Group,GroupStart - WS_GROUP
Флаг TabStop - позволяет пропускать контрол при перемещении фокуса клавиатурой. Но, если фокус ввода был 
установлен мышкой - то контрол таки получает фокус ввода.
Флаг NeedTabs - означает, что нельзя сменить фокус ввода с данного элемента нажатием таба - символ таба будет отправлен в контрол
Флаг CantOwnFocus,FocusLess - контрол не может иметь фокус ввода, даже если по нему кликнули мышкой.
Флаг Draggable.
Флаг PaintTransparent - не рисует никакого фона
Флаг HitTransparent   - "прозрачен" для hitTest - на hitTest проверяются только дочерние контролы. Ставим для всяких панелей, layout'ов и подобных контролов.
Флаг Dragged.
Флаг DragTarget. Или, является ли контрол DragTarget'ом - должно определяться типом перетаскиваемого элемента?
Флаг InTransitionAnimation - контрол находится в процессе анимации перехода из одного состояния в другое,
     и любые события игнорируются. Отдельно, у контрола может быть и анимированное конечное сотстояние,
     но в таком состоянии контрол обрабатывает ввод.
     Если у контрола стоит флаг InTransitionAnimation или он находится в анимированном состоянии, должен ли 
     он рисоваться в отдельной фазе рисования, вот в чем вопрос? А как же Z-order? Ведь анимированный контрол
     может находиться далеко внизу, и может быть перекрыт другими контролами?
     Если отрисовывать анимированный контрол с учетом Z-order, то нам при изменении фазы любой анимации
     придётся перерисовывать всю сцену, что может быть весьма накладно. Если все анимированные контролы рисовать
     отдельной фазой, то статку можно кешировать, но тогда анимация всегда будет поверх всех других контролов 
     отображаться. Надо подумать!!!

Какие ещё флаги?


Идентификация контролов, типы, стили, идентификторы, состояния
Поглядываем сюда - https://www.w3schools.com/cssref/css_selectors.php
Нужно, чтобы в итоге родить что-то типа CSS, чтобы для смены оформления не нужно было переписывать код

typeString    - аналог CSS element, метод - getControlTypeString()
styleString   - аналог сущности CSS class, "class" не используем, во избежания коллизий в семантике с плюсовыми классами и/или какими-то другими
                getControlStyleString()
stateString   - аналог псевдокласса CSS. Возвращает строку с именем состояния контрола, например: pushed/unpushed, checked/unchecked, selected/unselected, и тп.
                getControlStateString()
idString      - идентификатор контрола. В принципе, может быть не уникальным. Задаётся пользователем
                getControlIdString()


Controls Drawing.

Для каждого предопределённого типа контрола существует свой интерфейс для его рисования.
Или не?
Тогда по другому.
Есть обобщенный интерфейс рисования контрола. 
drawContol( ICanvas *pCanvas
          , // Тут что-то ещё
          , int controlType // PushButton, RadioButton, CheckBox, ListView, TrieView etc
          , int controlState // для PushButton: Normal/Pushed, для RadioButton/CheckBox - 
            // 2State/3State RadioButton/CheckBox current state, и тп
          )

Для всех предопределённых типов контролов (controlType) есть жоско заданный enum, с base type - int.
Для каждого предопределенного типа контрола есть набор состояний с base type int, в зависимости от 
типа контрола.

Тут будут жоские грязные касты enum'ов в int, это конечно говно. Но другая альтернатива - это по 
отдельному интерфейсу для каждого предопределенного типа контролов. Но как быть, если пользователь
создаёт свой контрол, и свою фабрику для хиттестов и рисования? Ядро о таком контроле ничего не знает,
и возможности расширять ядро у пользователя нет

А если биндить в белку, и тем более получать оттуда хит-тестеры и дроверы, то там только int, другой 
типизации там нет.

Ещё вариант - const char* Control::getControlTypeName() - возвращает указатель на строку с именем типа.
Сравнение строк конечно хуже, чем сравнение констант, зато на кастах интов не объебаться.
И бинарно совместимо, и расширябельно.
Тогда int Control::getControlState() возвращает целое значение, описывающее текущее состояние контрола.
В зависимости от типа контрола может быть любым.

Тут пока не пришел к окончательному решению. Поспрошал на кывте - https://rsdn.org/forum/cpp.applied/8711333.1
Там пока никто ничего полезного не подсказал, придётся самому думать.


Анимация трансформаций состояний контролов

Пример (сейчас все любят эффекты):
 Чек-бокс. Квадратный. Есть галочка, нет её - отображается одинаково.
   Чекаем. Рамка распухает, галочка (если не было) вырастает, если была - уменьшается
 Радио-батон. Чекаем. кружочек плавно уменьшается или вырастает с нуля, в зависимомти от предыдущего
   состояния.

Ну и все типа такого

Это всё надо отдать на откуп пользователю

!!! Обдумать. Все механизмы вроде есть, но надо думать



TokenDictionary
В принципе, идея заменить некоторое множество фиксированных строк на целочисленные идентификаторы - не плохая.
Это - стандартные типы контролов, стандартные состояния стандартных контролов, стандартные псевдоклассы, и тд и тп.
Также должна быть возможность добавлять пользовательские строки.
Изначально есть какой-то набор базовых строк, с заранее известными константными идентификаторами, которые можно использовать в коде
без обращения к словарю.
В этом есть плюс - экономия памяти и времени на сравнении строк. Для больших ПК это в общем-то насрать, но если решим затулить либу 
контролов в микроконтроллер, то там это будет играть рояль.

Добавление строк в словарь
 1) Добавление строк в словарь с заданным идентификатором
    bool addToken(TokeType tk, string mainName, vector<string> allNames)
    Добавление строк c фикс идентификаторами может происходить неоднократно, если такая строка уже есть, то токен, ей соответствующий,
    должен соответствовать заданному параметром функции, иначе - ошибка.
 2) Добавление произвольных строк в словарь.
    TokeType addToken(string name)
    Пользовательские строки имеют другой диапазон, с автоинкрементом глобального счетчика словаря при добавлении нового элемента.
    При этом, в зависимости от свойств словаря, он может сделать несколько записей для имени, так, для строки SomeVar могут быть
    добавлены строки SomeVar, someVar, some-var, some_var.
    При этом оригинальное имя "name" будет использовано для преобразования идентификатора токена в строку.

В целом, для известных имён будет некоторая оптимизация. С одной стороны, это экономия на спичках, но с другой стороны - 
при заталкивании либы в ограниченные ресурсы это может сыграть некоторую рояль. А потом всё переделывать будет уже поздно.

Тип токена сделаем std::uint16_t - 1) Делаем UnknownToken с кодом 0; 2) 65К токенов хватит на всех; 3) вектор токенов можно
представлять в виде std::basic_string<std::uint16_t>, что для коротких векторов вполне может дать small string optimization, 
что тоже неплохо. И такой стринг можно использовать при поиске подходящего CSS-стиля вообще без запар, и это уже может реально
влиять на производительность.





