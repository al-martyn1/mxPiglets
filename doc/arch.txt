
getCanvas() - возвращает не указатель, а экземпляр Canvas для рисования не в OnPaint. Это не в базе, 
  а в реализации. Или не? На самом деле, пусть возвращает shared_ptr<ICanvas> - по факту нам канвас не нужен 
  на каждый чих, и ремап мышкиного положения в позицию на канвасе нужен в мышиных событиях, и всё. 
  А там и так нужен канвас.

getCanvasForPaintEvent() - возвращает shared_ptr<ICanvas> для события OnPaint. В винде есть разделение 
  по способу получения HDC в зависимости от типа события. В других системах методов может быть больше
  - будем добавлять вирт методы по нужде, или меньше - тогда везде реализация будет одинаковая.

void prepareCanvasScaleOffset(shared_ptr<ICanvas>) - туда передаётся указатель, там Canvas настраивается. 
  Метод нужен в тч, чтобы прокинуть его в белку, и знать, как белка его настроила. Это вирт метод в базе.
  Отдельный хендлер в белке!!!

При этом в канвасе уже должен быть выбран кешированный бекграунд.
Или не?
bool selectCachedBackground(shared_ptr<ICanvas>) - метод для загрузки кешированного фонового изображения в канвас.
  Возвращает true, если в canvas было загружено кешированное фоновое изображение
  Пользователь тут может выбрать в канвас кешированное изображение бекграунда и вернуть true, или вернуть false 
  для отрисовки бекграунда, или выбрать вообще самое фоновое-фоновое изображение и вернуть false, чтобы поверх
  самого-самого фонового изображения пользователь отрисовал свой буль-менее статичный бекграунд, который
  будет кеширован.

Примерные сценарии при условии использования библиотеки виджетов совместно с игровым движком:

Последовательность событий рисования для отрисовки сцены с нуля (например, в onPaint):
  0) Создаём Canvas - getCanvasForPaintEvent
     Настраиваем - prepareCanvas
  1) drawSceneBackground        - отрисовка фона сцены. Тут после отрисовки производим кеширование бекграунда.
     Отдельный хендлер в белке!!!
  2) drawSceneAnimation         - отрисовка текущих фаз анимации спрайтов и тп.
     Отдельный хендлер в белке!!!
  3) drawSceneControls          - отрисовка статичных контролов.
     Отдельный хендлер в белке!!!
  4) drawSceneControlsAnimation - отрисовка текущих фаз анимации контролов, которые меняют своё состояние.
     Отдельный хендлер в белке!!!
  5) drawDragItems              - отрисовка динамической фигни по перетаскиванию контрола и/или спрайта
     Отдельный хендлер в белке!!!
  6) drawMouseState             - отрисовка всякой динамической фигни, которая меняется в мышиных событиях,
     Отдельный хендлер в белке!!!
     например, при нажатии кнопки мыши, для выделения какого-то региона - отрисовываем рамку выделения, 
     например, в данном случае - это событие дёргается, когда мы перерисовываем сцену, но не в обработчике мыши;
     или какой-то текущий хот-трекинг, но опять же не в машкином событии.
     Раньше для подобного делали просто XOR-рисвоание, но это убого выглядит на текущий момент.

У нас есть таймерное событие, которое вызывает пересчет положений элементов сцены.
По результатам этого пересчета сцена может измениться, но может и остаться неизменной (подразумевается основной бекграунд сцены).

Если сцена требует обновления основного бекграунда сцены, то invalidateAll и идём по предыдущему сценарию. Иначе алгоритм такой:
  0) Создаём Canvas - getCanvas
     Настраиваем - prepareCanvas
  1) if (!selectCachedBackground(pCanvas)
        {
            // Отдельный хендлер в белке!!!
            drawSceneBackground(pCanvas); // Тут после отрисовки производим кеширование бекграунда.
        }
  2-6) Как в предыдущем сценарии


По событиям мыши отрисовка работает по предыдущему сценарию, кроме пункта 6 - вместо этого в мышиное событие
передаётся канвас, и юзер там резвится, как хочет, но запоминая свои приколюхи для того, чтобы по требованию
они были перерисованы в drawMouseState.

Основная цель такого дробления отрисовки на фазы в том, чтобы пользователь мог поверх игрового поля c 
анимациями и прочим пользоваться стандартными контролами, при этом он может заменить отрисовочный хендлер 
контролов на свой, и рисовать контролы в своём оригинальном стиле - поддержка "тем".

У нас сейчас есть GDI и GDI+ бекэнды. GDI шустр, GDI+ - красив при рисовании линий и тп, делает размытие,
но тормоз. Тем не менее, BitBlt, StrechBlt, да и AlphaBlend - довольно шустры даже на довольно старых 
процессорах. Торомза возникают при большом количестве примитивов типа линий, прямоугольников, окружностей/
эллипсов и тд и тп, особенно с GDI+. А контролы - это как раз в основном такие примитивы.

Другие бекэнды, ориентированные на работу с графическим процессором веротяно работают быстрее, но не факт,
что там можно что-то закешировать. В этом случае selectCachedBackground всегда будет возвращать false.

Если у нас игра, то экран занят скорее всего игровым полем, и контролов на нём минимальное количество. 
Тут нет особых проблем в быстродействием.

Если у нас игра, и мы нажали, например, Escape - у нас появилось меню, обычно из кнопок - и в фоне либо
всё замирает, либо основной бекграунд остаётся неизменным, но анимации подёргиваются/анимируются, чтобы
пользователю было не скучно. Поверх этого обычно рисуется меню из кнопок и работает подсистема контролов.
sceneUpdate при этом по таймеру не вызывается, перерисовка базы сцены не нужна, и всё работает приемлемо
по скорости. 

А что, если у нас не игровое приложение? Тут, наверное, надо либо запретить UpdateScene таймер, либо не
иметь его вообще. А если у нас приложение-мутант - в какие-то моменты - офисное, в какие-то моменты -
игровое - наверное надо дать пользователю (конечному программисту) возможность управлять данным аспектом.

Надо ли нам вводить концепцию clipping regions? Для GDI/GDI+ наверное это могло бы что-то ускорить.
В других бекэндах не факт, что это вообще существует, и, весьма вероятно, что они настолько быстры в 
отрисовке, что там насрать на эти clipping regions и они, если и есть, то только будут тормозить. 
Возвожно, что перерисовать сцену целиком будет быстрее, чем мудохаться с обновлением сцены с учетом 
clipping regions.

Тем не менее, вопрос производительности надо держать в уме. Если мы перерисовываем
отдельный контрол, то в некоторых случаях нам может быть дешевле заново восстановить фон под ним,
и отрисовать текущее состояние контрола на восстановленом фоне, чем перерисовывать все контролы.
В других случаях дешевле будет рисовать всё с нуля.

!!! Тут пока нет однозначного решения, которое можно было бы сделать универсальным, и тюнить
его через настройки конкретной рализации. Надо думать !!!


Контролы

Размеры и положение

Размеры и положение контролов задаются в координатах канваса относительно родительского контрола
и не учитывают scale и offset canvas'а - он сам их аплаит при всех отрисовках. 


Контролы могут быть объединены в группы контролов. Им нужен для этого какой-то контейнер.
Наверное, это будет тоже Control, какой-то базовый контрол, типа Panel, наверное, практически прямой 
наследник ControlBase.

Вопрос - а нафига иметь Panel, который закрашивает фон каким-то цветом? Если у нас форма, то заливкой
фона занимается она, если у нас игра, то нам никакая заливка не нужна, мы рисуем поверх игры.
Окей - Panel не занимается закраской фона, Panel - прозрачный.
Если нам нужен непразрачный Panel - тут либо отдельный класс OpaquePanel, либо свойство transparency,
со значением по умлчанию - transparent.


Идентификаторы для библиотечных контролов

Нужны целочисленные идентификаторы для всех библиотечных контролов, для идентификации их типов в различных
фабриках. Пользователи могут создавать свои типы контролов. Все касты остаются на совести пользователей.

Или не целочисленные, а строковые? Это более гибко и перспективно в плане расширения.


Controls HitTest.

По дефолту у нас все контролы - прямоугольники. Но это не факт. Контролы могут быть фигурными донельзя,
особенно в игре.
Нам нужен HitTestHandler - если не задан, вызывается по умолчанию rectHitTestHandler.
У каждого контрола должна быть возможность иметь свой HitTestHandler.
Контейнеры игнорируют это поле.
По умолчанию контролу присваивается дефолтный HitTestHandler, если фабрике контролов не задана фабрика
HitTestHandler'ов.

Если HitTestHandler не знает, для какого типа контрола он вызывается, работает стандартный rectHitTestHandler.


Панели и подобные контейнеры контролов.
Панели и контейнеры не должны по идее получать сообщения мышки и клавиатуры, им самим это особо не зачем.
Но они должны уметь находить контрол в своём содержимом, на котором произошел клик.
Наверное это поведение не стоит зашивать, а оно будет управляться флагом - alowSelfHitTest или disableSelfHitTest.


Z-order. Для простоты Z-order будет определяться порядком контрола в векторе контейнера.
В начале - меньший z-order, в конце - больший. HitTest производится от начала к концу, 
отрисовка - от конца к началу.

Какой контейнер использовать для дочерних контролов? vector? list? deque? Или самому список запилить, указатели 
prev/next прямо в контроле?


TabOrder - хм, надо подумать, как это сделать. Целочисленное поле? При добавлении контрола оно автоматом 
увеличивается относительно предыдущего, или можно установить явно (и при этом переустановить счетчик 
автоматического TabOrder'а?)

Группы контролов, по которым можно перемещаться курсорными клавишами. Обдумать???

Флаги контрола (см также https://learn.microsoft.com/en-us/windows/win32/winmsg/window-styles)

Group,GroupStart - WS_GROUP
Флаг TabStop - позволяет пропускать контрол при перемещении фокуса клавиатурой. Но, если фокус ввода был 
установлен мышкой - то контрол таки получает фокус ввода.
Флаг NeedTabs - означает, что нельзя сменить фокус ввода с данного элемента нажатием таба - символ таба будет отправлен в контрол
Флаг CantOwnFocus,FocusLess - контрол не может иметь фокус ввода, даже если по нему кликнули мышкой.
Флаг Draggable.
Флаг Dragged.
Флаг DragTarget. Или, является ли контрол DragTarget'ом - должно определяться типом перетаскиваемого элемента?
Флаг InTransitionAnimation - контрол находится в процессе анимации перехода из одного состояния в другое,
     и любые события игнорируются. Отдельно, у контрола может быть и анимированное конечное сотстояние,
     но в таком состоянии контрол обрабатывает ввод.
     Если у контрола стоит флаг InTransitionAnimation или он находится в анимированном состоянии, должен ли 
     он рисоваться в отдельной фазе рисования, вот в чем вопрос? А как же Z-order? Ведь анимированный контрол
     может находиться далеко внизу, и может быть перекрыт другими контролами?
     Если отрисовывать анимированный контрол с учетом Z-order, то нам при изменении фазы любой анимации
     придётся перерисовывать всю сцену, что может быть весьма накладно. Если все анимированные контролы рисовать
     отдельной фазой, то статку можно кешировать, но тогда анимация всегда будет поверх всех других контролов 
     отображаться. Надо подумать!!!

Какие ещё флаги?


Идентификация контролов, типы, стили, идентификторы, состояния
Поглядываем сюда - https://www.w3schools.com/cssref/css_selectors.php
Нужно, чтобы в итоге родить что-то типа CSS, чтобы для смены оформления не нужно было переписывать код

typeString    - аналог CSS element, метод - getControlTypeString()
styleString   - аналог сущности CSS class, "class" не используем, во избежания коллизий в семантике с плюсовыми классами и/или какими-то другими
                getControlStyleString()
stateString   - аналог псевдокласса CSS. Возвращает строку с именем состояния контрола, например: pushed/unpushed, checked/unchecked, selected/unselected, и тп.
                getControlStateString()
idString      - идентификатор контрола. В принципе, может быть не уникальным. Задаётся пользователем
                getControlIdString()


Controls Drawing.

Для каждого предопределённого типа контрола существует свой интерфейс для его рисования.
Или не?
Тогда по другому.
Есть обобщенный интерфейс рисования контрола. 
drawContol( ICanvas *pCanvas
          , // Тут что-то ещё
          , int controlType // PushButton, RadioButton, CheckBox, ListView, TrieView etc
          , int controlState // для PushButton: Normal/Pushed, для RadioButton/CheckBox - 
            // 2State/3State RadioButton/CheckBox current state, и тп
          )

Для всех предопределённых типов контролов (controlType) есть жоско заданный enum, с base type - int.
Для каждого предопределенного типа контрола есть набор состояний с base type int, в зависимости от 
типа контрола.

Тут будут жоские грязные касты enum'ов в int, это конечно говно. Но другая альтернатива - это по 
отдельному интерфейсу для каждого предопределенного типа контролов. Но как быть, если пользователь
создаёт свой контрол, и свою фабрику для хиттестов и рисования? Ядро о таком контроле ничего не знает,
и возможности расширять ядро у пользователя нет

А если биндить в белку, и тем более получать оттуда хит-тестеры и дроверы, то там только int, другой 
типизации там нет.

Ещё вариант - const char* Control::getControlTypeName() - возвращает указатель на строку с именем типа.
Сравнение строк конечно хуже, чем сравнение констант, зато на кастах интов не объебаться.
И бинарно совместимо, и расширябельно.
Тогда int Control::getControlState() возвращает целое значение, описывающее текущее состояние контрола.
В зависимости от типа контрола может быть любым.

Тут пока не пришел к окончательному решению. Поспрошал на кывте - https://rsdn.org/forum/cpp.applied/8711333.1
Там пока никто ничего полезного не подсказал, придётся самому думать.


Анимация трансформаций состояний контролов

Пример (сейчас все любят эффекты):
 Чек-бокс. Квадратный. Есть галочка, нет её - отображается одинаково.
   Чекаем. Рамка распухает, галочка (если не было) вырастает, если была - уменьшается
 Радио-батон. Чекаем. кружочек плавно уменьшается или вырастает с нуля, в зависимомти от предыдущего
   состояния.

Ну и все типа такого

Это всё надо отдать на откуп пользователю

!!! Обдумать. Все механизмы вроде есть, но надо думать


























